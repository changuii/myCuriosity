# MessageBroker

취업공고를 보던 도중 toss bank에서 사용하는 kafka라는 MessageBorker가 무엇이고 어떤일을 하는 것인지 궁금해서 찾아보게 되었습니다.


## IBM

[원문링크](https://www.ibm.com/kr-ko/topics/message-brokers#:~:text=%EB%A9%94%EC%8B%9C%EC%A7%80%20%EB%B8%8C%EB%A1%9C%EC%BB%A4%EB%8A%94%20%EB%A9%94%EC%8B%9C%EC%A7%95%20%EB%AF%B8%EB%93%A4%EC%9B%A8%EC%96%B4,%EC%97%90%20%EC%A0%84%EB%85%90%ED%95%A0%20%EC%88%98%20%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4.)  

메시지 브로커는 애플리케이션, 시스템 및 서비스가 서로 간에 통신하고 정보를 교환할 수 있도록 해주는 소프트웨어입니다. 이를 위해 메시지 브로커는 정규 메시징 프로토콜 간에 메시지를 변환합니다. 그러면 상호 의존적인 서비스는 상이한 언어로 작성되거나 상이한 플랫폼에서 구현된 경우에도 서로 간에 직접 "대화"를 실시할 수 있습니다.  

메시지 브로커는 메시징 미들웨어 또는 메시지 지향 미들웨어(MOM) 솔루션 내의 소프트웨어 모듈입니다. 이러한 유형의 미들웨어는 애플리케이션의 구성요소 간에 데이터의 플로우를 처리하는 표준화된 수단을 개발자에게 제공합니다. 그러면 개발자는 코어 로직 개발에 전념할 수 있습니다. 그러면 다수의 플랫폼에 구현된 애플리케이션의 내부적인 통신을 가능하게 하는 분산 통신 계층의 역할을 수행하게 됩니다.  

메시지 브로커는 메시지를 검증, 저장, 라우팅하고 이를 적절한 대상에 전달할 수 있습니다. 다른 애플리케이션 간의 중개자 역할을 함으로써 수신자의 위치, 수신자가 활성인지 여부 또는 수신자의 수를 잘 몰라도 송신자가 메시지를 발행할 수 있게 합니다. 그러면 시스템 내에서 프로세스와 서비스의 디커플링이 용이해질 수 있습니다.  

- 여러 서버들이 상호작용할 수 있도록 도와주는 소프트웨어? 
- MSA 처럼 상이한 언어와 상이한 플랫폼의 서버들이 서로 상호작용할 수 있도록 도와줄 수 있는가?


## tistory

메시지 브로커를 왜 사용하는 것일까?  
[원문링크](https://binux.tistory.com/74)  

1. 서비스 간의 의존성 제거
2. 메시지 처리 시점
3. 다양하고 유연한 통신


### 서비스간의 의존성 제거  
- 메시지 브로커 없이는 송신 및 수신 서버가 모두 다 정상적으로 작동하는 상태여야만 메시지 전송이 정상적으로 동작하게 됩니다.  
- 문제가 없는 상황에서도 메시지 전달은 보장되어야만 합니다. 이러한 메시지 보장에 대한 메커니즘을 전달 보장 메커니즘(Guaranteed delivery mechanism)이라고 하는데요. 메시지 브로커가 없는 상황에서는 송신 또는 수신측에 직접 구현을 해야할 것입니다. 이러한 메커니즘을 구현하기는 쉽지 않을 뿐더러 특정 어플리케이션 관계마다 구현해주기 더 쉽지 않겠죠

서버의 수가 유동적이면 정상적으로 동작이 어려움 (서비스 검색 불가상황)  
송신 및 수신 서버가 모두 정상적으로 동작해야만 한다는 것  
전달 보장 메커니즘이 없거나 구현하기 어려움  

메시지 브로커는 이러한 어플리케이션 의존성을 제거해줌으로써 앞선 문제들을 해결해주고 있습니다.  

서버 수가 유동적이어도 정상적으로 동작합니다.

- 송신 측 서버가 늘어나도 메시지 브로커의 주소만 알고 있다면, 메시지를 보내는데는 문제가 없습니다.
- 수신 측 서버가 늘어나도 메시지 브로커의 주소만 알고 있다면, 메시지를 받아오는데는 문제가 없습니다.

수신 측 서버가 문제가 생겨도 정상적으로 동작합니다.
- 송신 측이 메시지를 보내면, Message Broker는 메시지를 받아 큐에 저장해놓고 수신 측이 받아가길 기다립니다.  
- 수신 측 서버에 문제가 생겨 이 메시지를 받아가지 못하더라도 메시지 브로커에서는 정해둔 설정 값마다 다르겠지만 메시지를 유지하고 있습니다. 수신 측 서버가 정상적으로 돌아오면 그 유지해 두었던 메시지를 받아 올 수 있어 문제가 생겼던 기간의 메시지들도 받을 수 있습니다.

그럼, 만약 메시지 브로커 자체가 죽으면 어떻게 될까요?
- 브로커 자체가 죽는다고 송신 및 수신 측 서버에 부담이 가지 않습니다. 메시지 전송의 출구만 없어질 뿐 그 자체의 서버 역할을 하고 있을 것입니다. 하지만 당연히도 메시지 전송 기능 자체에는 문제가 발생할 수 있습니다.
- 하지만 메시지 브로커 서버는 일반 서버와 달리 메시지 전송과 메시지 큐 부분에만 집중을 둔 서버로서 고가용성을 목표로 만들어져있어 서버가 이상이 있을 위험이 더 적다고 합니다.  

### 메시지 처리 시점

메시지 브로커에서는 수신 측에서 원하는 시점에 메시지를 가져갈 수 있도록 (처리할 수 있도록) 지원하고 있습니다. 여기서 원하는 시점이란 유동적일 수도 있겠지만 보통 수신 측이 메시지를 처리할 수 있는 시점을 의미합니다. 이러한 기능을 '메시지 버퍼링'이라고 부르기도 합니다.  

- 다시 말해서, 메시지 브로커는 수신 측에서 처리 가능한 시점까지 메시지를 버퍼링 할 수 있는 것입니다.


### 다양하고 유연한 통신


수신 측 서버의 개수는 2개일 수도, 3개일 수도, 많게는 10개일 수도 있습니다. 이러면 송신 측에선 어떻게 해야할까요?  

만약 현재의 구조대로라면 내부 코드에서 수신 측 주소로 직접 요청하는 식으로 구현을 해두어야겠죠? 정말 많은 불편함이 있을 것이며, 어느때(서버의 대수가 유동적으로 변경되는 시점)가 되면 이게 불가능한 시점이 올 수도 있습니다.  

- 메시지 브로커에서는 다양한 메시지 채널 방식을 지원하고 있고, 점대점(point-to-point) 및 발행-구독(pub-sub) 채널은 보통 지원을 하고 있어 위에서 설명하던 구조를 쉽게 구현할 수 있습니다. 


## 정리

MessageBroker는 클라이언트와 서버 사이에서 메시지 생산자와 소비자가 메시지를 언제든지 빼고 넣을 수 있도록 버퍼링을 해주는 역할을 해준다.  

특히, 서비스간의 의존성 제거, 메시지 처리시점, 다양하고 유연한 통신을 가능하게 한다.  



 






